{
    "problem": {
        "title": "Natlan Exploring",
        "description": "You are exploring the stunning region of Natlan! This region consists of n cities, and each city is rated with an attractiveness a i . A directed edge exists from City i to City j if and only if i < j and gcd ( a i , a j ) ≠ 1 , where gcd ( x , y ) denotes the greatest common divisor (GCD) of integers x and y . Starting from City 1 , your task is to determine the total number of distinct paths you can take to reach City n , modulo 998 244 353 . Two paths are different if and only if the set of cities visited is different.",
        "input_specification": "The first line contains an integer nn (2≤n≤2⋅1052≤n≤2⋅105) — the number of cities.The second line contains nn integers a1,a2,…,ana1,a2,…,an (2≤ai≤1062≤ai≤106) — the attractiveness of each city.",
        "output_specification": "Output the total number of distinct paths you can take to reach City nn, modulo 998244353998244353.",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "combinatorics",
            "data structures",
            "dp",
            "math",
            "number theory"
        ],
        "examples": [
            {
                "input": "5\n2 6 3 4 6",
                "output": "5\n"
            }
        ],
        "difficulty": "hard"
    },
    "solution": {
        "description": "Denote dp[i]=dp[i]= the number of ways to get to city ii. Brute-forcing all possible previous cities is out of the question, as this solution will take O(n2⋅log(maxai))O(n2⋅log⁡(maxai)) time complexity. What else can we do?Instead, consider caseworking on what the greatest common factor can be. Let's keep track of an array countcount which for index ii keeps track of the sum of dpdp values of all previous cities who has a factor of ii. Say the current city has attractiveness aiai. We can almost recover dp[i]dp[i] by adding up the countcount values of all factors of aiai. Unfortunately, this fails as it overcounts many instances. For example, if gcd(ai,aj)=12gcd(ai,aj)=12 the dpdp state from ii will be counted five times: 2,3,4,6,122,3,4,6,12.Note that we don't actually care what the greatest common factor is, since the only requirement is that the greatest common factor is not 11. This also means that repeat appearances of the same prime number in the factorization of aiai doesn't matter at all — we can assume each prime factor occurs exactly once. Now, if gcd(ai,aj)=12gcd(ai,aj)=12, it is only counted three times: 2,3,62,3,6. Now, instead of blindly adding the countcount values from all previous states, let's instead apply the Principle of Inclusion-Exclusion on the prime factors. Let's first add the countcount values from all prime factors, then subtract the countcount values from all factors with two prime factors, then add the countcount values from all factors with three prime factors, and so on. It can be seen that actually, the value is only counted one time now.So what's the time complexity of this solution? Precomputing the set of all prime number takes O(max(ai)log(max(ai)))O(max(ai)log⁡(max(ai))) time (by the harmonic series n1+n2+…+nn≈nlog(n)n1+n2+…+nn≈nlog⁡(n)). For each number aiai, we have to consider all 2f(ai)2f(ai) subsets of prime factors, where f(ai)f(ai) is the number of prime factors of aiai. The number with the most distinct prime factors is 510510=2⋅3⋅5⋅7⋅11⋅13⋅17510510=2⋅3⋅5⋅7⋅11⋅13⋅17, so worst case 27=12827=128 operations are needed per number. This goes to a total operation count of approximately 128⋅n128⋅n which will pass in the time limit.Note that we may also use the Mobius function to compute the answer. The Mobius function's properties makes it utilize the Principle of Inclusion-Exclusion efficiently. The time complexity of this solution is O(max(ai)log(max(ai))+nmax(d(ai)))O(max(ai)log⁡(max(ai))+nmax(d(ai))) where d(ai)d(ai) is the maximum number of factors of aiai. This time complexity can be shown to be the same as the above time complexity.",
        "code": "import sys\n\ndef input():\n    return sys.stdin.buffer.readline().strip()\n\nMOD = 998244353\nma = int(1e6 + 5)\nP = [1] * ma\nD = [[] for _ in range(ma)]\nfor i in range(2, ma):\n    if P[i] == 1:\n        for j in range(i, ma, i):\n            P[j] = i\nF = [0] * ma\nLU = [0] * ma\nBMS = [[] for _ in range(ma)]\nRES = []\nfrom itertools import combinations\ndef getBMS(x):\n    if not BMS[x]:\n        y = help(x)\n        for i in range(len(y)):\n            p = combinations(y, i + 1)\n            for a in p:\n                xx = 1\n                for j in a:\n                    xx *= j\n                BMS[x].append((xx,i))\n    return BMS[x]\ndef helps(x):\n    y = x\n    while x != 1:\n        s = P[x]\n        D[y].append(s)\n        while x % s == 0:\n            x //= s\n\n\ndef help(x):\n    if not D[x]: helps(x)\n    return D[x]\n\n\n\n\nfor yy in range(int(input())):\n    n = int(input())\n    A = list(map(int, input().split()))\n    for xx,i in getBMS(A[0]):\n        F[xx] = 1\n        LU[xx] = yy\n    for i in range(1, n - 1):\n        tot = 0\n        for xx, j in getBMS(A[i]):\n            if LU[xx] != - 1 and LU[xx] != yy:\n                F[xx] = 0\n            LU[xx] = yy\n            if F[xx]:\n                if j % 2:\n                    tot -= F[xx]\n                    tot %= MOD\n                else:\n                    tot += F[xx]\n                    tot %= MOD\n        for xx, j in getBMS(A[i]):\n            F[xx] += tot\n            F[xx] %= MOD\n    S = 0\n    for xx,i in getBMS(A[-1]):\n        if LU[xx] != - 1 and LU[xx] != yy:\n            LU[xx] = yy\n            F[xx] = 0\n        if F[xx]:\n            if i % 2:\n                S -= F[xx]\n                S %= MOD\n            else:\n                S += F[xx]\n                S %= MOD\n\n    RES.append(str(S))\nprint(\"\\n\".join(RES))"
    }
}