{
    "problem": {
        "title": "Balanced",
        "description": "You are given a cyclic array a with n elements, where n is odd . In each operation, you can do the following: Choose an index 1 ≤ i ≤ n and increase a i − 1 by 1 , a i by 2 , and a i + 1 by 1 . The element before the first element is the last element because this is a cyclic array. A cyclic array is called balanced if all its elements are equal to each other. Find any sequence of operations to make this cyclic array balanced or determine that it is impossible. Please note that you do not have to minimize the number of operations.",
        "input_specification": "Each test consists of multiple test cases. The first line contains a single integer tt (1≤t≤2⋅1051≤t≤2⋅105) — the number of test cases. The description of the test cases follows.The first line of each test case contains a single integer nn (1≤n<2⋅1051≤n<2⋅105, nn is odd) — the length of the array aa.The second line of each test case contains nn integers a1,a2,…,ana1,a2,…,an (1≤ai≤1061≤ai≤106) — the elements of the array aa.It is guaranteed that the sum of nn over all test cases does not exceed 2⋅1052⋅105.",
        "output_specification": "For each test case: If it is impossible to make the cyclic array balanced, output −1−1. Otherwise, output nn integers v1,v2,…,vnv1,v2,…,vn (0≤vi≤10180≤vi≤1018) — where vivi denotes the number of operations applied to index ii. It can be proved that if any solution exists, then there exists a solution under the given constraints. If there are several solutions under the given constraints, output any of them.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "greedy",
            "implementation",
            "math"
        ],
        "examples": [
            {
                "input": "6\n3\n2 1 2\n3\n1 2 3\n5\n1 2 1 2 1\n7\n1 2 1 2 1 3 1\n9\n10000 10000 10000 10000 10000 10001 10002 10001 10000\n1\n10",
                "output": "0 1 0 \n2 1 0 \n2 0 3 0 2 \n4 2 7 0 8 0 6 \n1 1 1 1 1 1 0 1 1 \n0 \n"
            }
        ],
        "difficulty": "hard"
    },
    "solution": {
        "description": "2032E - BalancedTo simplify this problem a little bit before starting, we will temporarily allow \"negative\" operation: choose an index 1≤i≤n1≤i≤n and increase ai−1ai−1 by −1−1, aiai by −2−2, and ai+1ai+1 by −1−1. This is counted as −1−1 operation on index ii. Should we get negative elements in array vv in the end, we can normalize it just fine by subtracting all vivi with minviminvi so that the final array vv is valid — it's trivial to prove that applying the same amount of operations in all indices does not change the relative difference between any two values in the array.Imagine we have n=3n=3 and array a=[a1,a2,a3]a=[a1,a2,a3] where a1≥a2≤a3a1≥a2≤a3; i.e., a trench. This array always has at least one solution: try to balance a1a1 and a3a3 by adding an amount of operation on either side based on their difference — here we have something we'll denote as a \"balanced trench\", then add another amount of operations on index 22 to balance them three, and due to the cyclic nature of aa.In fact, every array with n=3n=3, without regards to value intensity, can be thought of this form — if a2a2 is higher than both a1a1 and a3a3, the act of \"raising\" a2a2 is actually applying a negative amount of operations to index 22.How to make a \"balanced trench\" for n>3n>3?At least, we can balance a1a1 and anan in the same fashion as we did for n=3n=3. Can we balance a2a2 and an−1an−1 without breaking the balance we achieved between a1a1 and anan?Assuming we have an array [0,x,y,x+1,0][0,x,y,x+1,0].By logic, we want to increase the value of index 22.Applying an operation to index 11 won't do, as the new array would be [2,x+1,y,x+1,1][2,x+1,y,x+1,1]. We are balancing the inner elements by sacrificing the outer ones.Applying an operation to index 33 also won't do as it increases both sides.Applying an operation to index 22 will make the array become [1,x+2,y+1,x+1,0][1,x+2,y+1,x+1,0]. By applying another operation to index 55, we'll reach our desired goal with array [2,x+2,y+1,x+2,2][2,x+2,y+1,x+2,2].In fact, a series of operations in \"consecutive\" indices of the same parity would have this effect, regardless of how long that series is.To be precise, without loss of generality, a series of operations in indices 2,4,…,i2,4,…,i, with i≤n−1i≤n−1, will increase a1a1 and ai+1ai+1 by 11, and all values with indices in range [2,i][2,i] by 22.The catch here is that we mitigate 11 unit of difference between sides with each operation series by adding just 11 unit to the higher side, while the corresponding other 11 would be further beyond the lower side.If we aim to balance the sides from outwards to inwards, that exceeding 11 will either fall into a deeper-inwards layer, or the center of the array (since nn is odd), which will not harm whatever we have achieved at first.Take an example with array [48,18,26,57,39][48,18,26,57,39]. First, we'll balance index 11 and index 55. We can simply apply 99 operations to index 55. The new array would be [57,18,26,66,57][57,18,26,66,57]. Then, we'll balance index 22 and index 44. From index 22, we'll move to the left until it reaches index 55, and apply 4848 operations for every 22 steps. In other words, apply 4848 operations to index 22 and 4848 operations to index 55. This array is now a balanced trench: [153,114,64,114,153][153,114,64,114,153]. Now, achieving the desired array (we'll call it a \"plateau\") from a balanced trench is easy: starting from the rightmost element of the left side before the center going leftwards, compare the value to its adjacent element to the right, and apply a corresponding amount of operations.Now, take the balanced trench we just acquired. First, we'll check index 22. Clearly, we want to rise index 33 to close the 5050 unit gap, thus we'll apply 5050 operations to index 33. The new array will become [153,164,164,164,153][153,164,164,164,153]. Then, we'll check index 11. Our objective is to decrease 1111 for all elements with indices in range [2,4][2,4]. Using the similar operation series as discussed earlier, this can be done like this: apply −11−11 operations to index 22, then apply −11−11 operations to index 44. The final array will be [142,142,142,142,142][142,142,142,142,142]. That operation series can be used here because the range of elements changing by 22 units per series has an odd size, and since we're growing the plateau from the center point outwards, its size is always odd as well. With this, the non-normalized array vv will be [0,46,50,−11,57][0,46,50,−11,57].Implementing this method can be separated into two separate steps: Step 11 (creating the balanced trench): for each pair of indices (i,n+1−i)(i,n+1−i) with difference an+1−i−ai=dan+1−i−ai=d, apply dd operations for each index of the cyclic range [n+3−i,i][n+3−i,i] with step 22. Step 22 (creating the plateau): for each pair of indices (i,i+1)(i,i+1) with difference ai−ai+1=dai−ai+1=d, apply dd operations for each index of the range [i+1,n−i][i+1,n−i] with step 22. Some extra notes: Each step requires an independent prefix-sum structure to quickly maintain the operation updates. Notice that the prefix sum here takes account of parity, since only the other index in a range is updated, not every one of them. Remember that after each index considered, its value will alter based on the amount of operations just applied on it, so keep track of it properly. To avoid confusion, it's advised to apply the operations of step 11 directly into array aa before proceeding with step 22. Remember to normalize array vv before outputting to get rid of negative values. Refer to the model solution for more details. Time complexity: O(n)O(n).",
        "code": "class Solution:\n    hasMultipleTests = True\n\n    n: int = None\n    a: list = None\n\n    @classmethod\n    def apply_prefixes(cls, prefixes, v):\n        for i in range(2, cls.n*2):\n            prefixes[i] += prefixes[i - 2]\n        \n        for i in range(cls.n*2):\n            v[i % cls.n] += prefixes[i]\n\n    @classmethod\n    def construct_trench(cls, arr, v):\n        prefixes = [0 for _ in range(cls.n * 2)]\n        delta = [0 for _ in range(cls.n)]\n        \n        for i in range(cls.n // 2):\n            diff = arr[cls.n - 1 - i] - (arr[i] + delta[i])\n            \n            delta[i] += 2 * diff\n            delta[i + 1] += diff\n            \n            prefixes[cls.n - i] += diff\n            prefixes[cls.n + i + 2] -= diff\n        \n        cls.apply_prefixes(prefixes, v)\n        \n        for i in range(cls.n):\n            arr[i] += v[i] * 2\n            arr[(i + 1) % cls.n] += v[i]\n            arr[(i + cls.n - 1) % cls.n] += v[i]\n\n    @classmethod\n    def construct_plateau(cls, arr, v):\n        prefixes = [0 for _ in range(cls.n * 2)]\n        delta = [0 for _ in range(cls.n)]\n        \n        for i in range(cls.n // 2 - 1, -1, -1):\n            diff = arr[i] - (arr[i + 1] + delta[i + 1])\n            \n            delta[i] += diff\n            \n            prefixes[i + 1] += diff\n            prefixes[cls.n - i] -= diff\n        \n        cls.apply_prefixes(prefixes, v)\n\n    @classmethod\n    def preprocess(cls):\n        pass\n\n    @classmethod\n    def input(cls, testcase):\n        cls.n = int(input())\n        cls.a = list(map(int, input().split()))\n\n    @classmethod\n    def solve(cls, testcase):\n        if cls.n == 1:\n            return(print(0))\n        \n        v = [0 for _ in range(cls.n)]\n        \n        cls.construct_trench(cls.a, v)\n        cls.construct_plateau(cls.a, v)\n        \n        offset = min(v)\n        v = list(map(lambda x: x - offset, v))\n        \n        print(*v)\n\n# end Solution"
    }
}