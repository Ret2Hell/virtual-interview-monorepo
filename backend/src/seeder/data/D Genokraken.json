{
    "problem": {
        "title": "Genokraken",
        "description": "This is an interactive problem. Upon clearing the Waterside Area, Gretel has found a monster named Genokraken, and she's keeping it contained for her scientific studies. The monster's nerve system can be structured as a tree † of n nodes (really, everything should stop resembling trees all the time … ) , numbered from 0 to n − 1 , with node 0 as the root. Gretel's objective is to learn the exact structure of the monster's nerve system — more specifically, she wants to know the values p 1 , p 2 , … , p n − 1 of the tree, where p i ( 0 ≤ p i < i ) is the direct parent node of node i ( 1 ≤ i ≤ n − 1 ). She doesn't know exactly how the nodes are placed, but she knows a few convenient facts: If we remove root node 0 and all adjacent edges, this tree will turn into a forest consisting of only paths ‡ . Each node that was initially adjacent to the node 0 will be the end of some path . The nodes are indexed in a way that if 1 ≤ x ≤ y ≤ n − 1 , then p x ≤ p y . Node 1 has exactly two adjacent nodes (including the node 0 ). The tree in this picture does not satisfy the condition, because if we remove node 0 , then node 2 (which was initially adjacent to the node 0 ) will not be the end of the path 4 − 2 − 5 . The tree in this picture does not satisfy the condition, because p 3 ≤ p 4 must hold. The tree in this picture does not satisfy the condition, because node 1 has only one adjacent node. Gretel can make queries to the containment cell: \" ? a b \" ( 1 ≤ a , b < n , a ≠ b ) — the cell will check if the simple path between nodes a and b contains the node 0 . However, to avoid unexpected consequences by overstimulating the creature, Gretel wants to query at most 2 n − 6 times. Though Gretel is gifted, she can't do everything all at once, so can you give her a helping hand? † A tree is a connected graph where every pair of distinct nodes has exactly one simple path connecting them. ‡ A path is a tree whose vertices can be listed in the order v 1 , v 2 , … , v k such that the edges are ( v i , v i + 1 ) ( 1 ≤ i < k ).",
        "input_specification": "Each test consists of multiple test cases. The first line contains a single integer tt (1≤t≤5001≤t≤500) — the number of test cases. The description of the test cases follows.The first line of each test case contains a single integer nn (4≤n≤1044≤n≤104) — the number of nodes in Genokraken's nerve system.It is guaranteed that the sum of nn over all test cases does not exceed 104104.",
        "output_specification": "",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "graphs",
            "greedy",
            "implementation",
            "interactive",
            "trees",
            "two pointers"
        ],
        "examples": [
            {
                "input": "3\n4\n\n1\n\n5\n\n1\n\n0\n\n9\n\n",
                "output": "\n\n? 2 3\n\n! 0 0 1\n\n? 2 3\n\n? 2 4\n\n! 0 0 1 2\n\n! 0 0 0 1 3 5 6 7"
            }
        ],
        "difficulty": "hard"
    },
    "solution": {
        "description": "2032D - Genokraken For simplicity, we'll use the term \"tentacle\" to call each path tree in the forest made by cutting off node 00. We also notice that in each tentacle, two nodes will never have the same distance from root node 00.The condition of px≤pypx≤py iff x≤yx≤y leads to a crucial observation of the system: it is indexed in accordance to a BFS order of the tree. Hence, we now have two goals: Determine mm — the number of tentacles. From node m+1m+1 to n−1n−1, assign every node to their respective tentacles. Due to the BFS order, at the moment of assignment, the previous tip of the tentacle is the parent of the current node, and the current node becomes the new tip of the tentacle. For the first objective, we see that node 11 is guaranteed to be connected with nodes 00 and m+1m+1. Furthermore, m+1m+1 is the first non-zero node where the path between it and 11 does not cross 00. Therefore, you can keep querying (1,j)(1,j) for increasing jj until you find a 00 to get mm.For the second objective, we need to find the tentacle that each node ii (m+2≤i≤n−1m+2≤i≤n−1) belongs to; in other words, find the node 1≤i≤m1≤i≤m so that query (i,j)(i,j) yields a 00. Denote t(j)t(j) as the tentacle associated with node jj, then note that: If j−1j−1 and jj share the same distance from 00, then obviously t(j−1)<t(j)t(j−1)<t(j), i.e., t(j)t(j) will be a tentacle at the forward direction from t(j−1)t(j−1) in the tentacle list. If j−1j−1 and jj don't share the same distance from 00, then t(j)t(j) can be any tentacle in the list. So we can approach this objective like this: denote next(t(j−1))next(t(j−1)) as the next tentacle in the list after t(j−1)t(j−1) (or 11 if t(j−1)t(j−1) was at the end of the list), starting from i=t(j−1)i=t(j−1), we'll keep re-assigning i=next(i)i=next(i) until query (i,j)(i,j) yields a 00.From hindsight, it looks like we'll need O(n2)O(n2) query count order to finish this part, but there is another crucial observation: due to the nodes being indexed in BFS order, if any tentacle yields a 11 during probing, that tentacle will never be extended again — proof for this is pretty intuitive but a bit lengthy to express in words, so we'll leave it as an exercise for the reader — thus if you reach an ii that has already been deactivated before, you ignore it and call nextnext again, which wouldn't count towards the queries as it is your internal processing.Let's count the number of queries we used. Let m≤n−2m≤n−2 be the number of tentacles, then If m=n−2m=n−2, the second objective wouldn't be needed, so we end up with n−2≤2n−6n−2≤2n−6 queries in total (as n≤4n≤4). If m≤n−3m≤n−3, note that each time we process a query, either a node is appended to a tentacle, or a tentacle is removed. Since at most m−1m−1 tentacles can be removed and there are n−m−2n−m−2 nodes to be processed, the second phase uses at most n−3n−3 queries, so in total we use n+m−3≤2n−6n+m−3≤2n−6 queries. To process the list of tentacles, there are a few options: Naively mark the tentacles as active/inactive to know when to stop by for queries and when to skip. Time complexity will be O(n2)O(n2), and though it can still pass (in fact one such solution from the author passed nicely), it is not recommended. Maintain the list of tentacles in a set, if a node is known to be inactive, remove it. Time complexity will be O(nlogn)O(nlog⁡n). Maintain the list of tentacles in a similar manner as above, but using a doubly linked list this time. Time complexity will be O(n)O(n).",
        "code": "class DeleteOnly_DLL:\n    def __init__(self, size: int):\n        self.values = [None for _ in range(size)]\n        self.prev = [(i + size - 1) % size for i in range(size)]\n        self.next = [(i +        1) % size for i in range(size)]\n        self.pointer = 0\n    \n    def current(self):\n        return self.values[self.pointer]\n    \n    # Set value at pointer and move pointer to next\n    def set_and_move(self, val):\n        self.values[self.pointer] = val\n        self.pointer = self.next[self.pointer]\n        \n    # \"Delete\" node and move pointer to next\n    def erase(self):\n        if self.prev[self.pointer] != -1:\n            self.next[self.prev[self.pointer]] = self.next[self.pointer]\n        if self.next[self.pointer] != -1:\n            self.prev[self.next[self.pointer]] = self.prev[self.pointer]\n        \n        next_id = self.next[self.pointer]\n        self.prev[self.pointer] = self.next[self.pointer] = -1\n        self.pointer = next_id\n    \n# end DeleteOnly_DLL\n\n\nclass Solution:\n    hasMultipleTests = True\n\n    n: int = None\n    \n    @classmethod\n    def ask(cls, a: int, b: int):\n        print(f'? {a} {b}', flush=True)\n        return int(input())\n    \n    @classmethod\n    def answer(cls, p: list):\n        print(f'! {\" \".join(map(str, p[1:]))}', flush=True)\n\n    @classmethod\n    def preprocess(cls):\n        pass\n\n    @classmethod\n    def input(cls, testcase):\n        cls.n = int(input())\n\n    @classmethod\n    def solve(cls, testcase):\n        p = [-1 for _ in range(cls.n)]\n        p[1] = 0\n        \n        r = 2\n        while True:\n            response = cls.ask(1, r)\n            if response == -1: exit(2226)\n            \n            if response == 1:\n                p[r] = 0\n                r += 1\n            else: break\n        \n        tentacle_count = r - 1\n        \n        tentacles = DeleteOnly_DLL(size = tentacle_count)\n        for i in range(tentacle_count):\n            tentacles.set_and_move(i + 1)\n\n        p[r] = tentacles.current()\n        tentacles.set_and_move(r)\n        r += 1\n        \n        while r < cls.n:\n            response = cls.ask(tentacles.current(), r)\n            if response == -1: exit(2226)\n            \n            if response == 1:\n                tentacles.erase()\n            else:\n                p[r] = tentacles.current()\n                tentacles.set_and_move(r)\n                r += 1\n        \n        cls.answer(p)\n\n# end Solution"
    }
}