{
    "problem": {
        "title": "Peanuts",
        "description": "Having the magical beanstalk, Jack has been gathering a lot of peanuts lately. Eventually, he has obtained n pockets of peanuts, conveniently numbered 1 to n from left to right. The i -th pocket has a i peanuts. Jack and his childhood friend Alice decide to play a game around the peanuts. First, Alice divides the pockets into some boxes; each box will have a non-zero number of consecutive pockets, and each pocket will, obviously, belong to exactly one box. At the same time, Alice does not change the order of the boxes, that is, the boxes are numbered in ascending order of the indices of the pockets in them. After that, Alice and Jack will take turns alternately, with Alice going first. At each turn, the current player will remove a positive number of peanuts from exactly one pocket which belongs to the leftmost non-empty box (i.e., the leftmost box containing at least one non-empty pocket). In other words, if we number the boxes from left to right, then each player can only pick peanuts from the pocket in the j -th box ( j ≥ 2 ) only if the ( j − 1 ) -th box has no peanuts left. The player who cannot make a valid move loses. Alice is sure she will win since she has the advantage of dividing the pockets into boxes herself. Thus, she wanted to know how many ways there are for her to divide the peanuts into boxes at the start of the game so that she will win, assuming both players play optimally. Can you help her with the calculation? As the result can be very large, output it modulo 998 244 353 .",
        "input_specification": "Each test consists of multiple test cases. The first line contains a single integer tt (1≤t≤1041≤t≤104) — the number of test cases. The description of the test cases follows.The first line of each test case contains a single integer nn (1≤n≤1061≤n≤106) — the number of pockets.The second line of each test case contains nn integers a1,a2,…,ana1,a2,…,an (1≤ai≤1091≤ai≤109) — the number of peanuts in each pocket.It is guaranteed that the sum of nn over all test cases does not exceed 106106.",
        "output_specification": "For each test case, output a single integer — the number of ways for Alice to divide the pockets into boxes at the start of the game to guarantee her win, assuming both players play optimally, modulo 998244353998244353.",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "games",
            "math"
        ],
        "examples": [
            {
                "input": "5\n3\n1 2 3\n4\n1 2 3 1\n5\n1 1 1 1 1\n2\n1 1\n10\n1 2 3 4 5 6 7 8 9 10",
                "output": "1\n4\n16\n0\n205\n"
            }
        ],
        "difficulty": "hard"
    },
    "solution": {
        "description": "2032F - Peanuts Let's get the trivial case out of the way: If the peanut pockets always contain 11 nut each, then partitioning the pockets doesn't affect the game's outcome at all: Alice will always win if nn is odd, and there are 2n−12n−1 ways to partition nn pockets. Jack will always win if nn is even. Proof for the trivial case is, indeed, trivial.For the main problem, we see that this is a derivative of a game of Nim. To be exact, each box is a vanilla Nim game. To determine the winner of a vanilla Nim game when both players play optimally is trivial — if not for you, I strongly suggest reading about the game and the Sprague-Grundy theorem before continuing.In short, the Nim-sum of a Nim game is the xor sum of all values presented, and if that value is at least 11, the first player will win if they play optimally.The original game of this problem is a series of consecutive Nim games, with the loser of the previous game becoming the first player of the next game. Clearly, trying to win all the boxes isn't a correct approach — one of the simplest counterexamples is a partition with two boxes, both with the first player winning if played optimally, so of course if the first player \"wins\" the first box, they immediately lose the second one and thus lose the whole game.In short, sometimes, tactically \"losing\" some boxes might be required. But how to know which player would lose if they both aimed for it?Now, introducing the \"mirrored\" version of a Nim game — a Misère Nim game, where the winning condition is the original Nim game's losing condition.If the peanut pockets always contain 11 nut each, then the winner of a Misère Nim game can be easily declared by the parity of nn. Otherwise, the winner of a Misère Nim game can be decided using the same nimber used in a regular Nim game: if the nimber is not 00, the first player wins both the original and the Misère version; otherwise, the second player wins — the optimal strategies to acquire such outcome have the exact mirror intents of those in a regular Nim game.Also, surpassing the leading 11s in array aa, both Alice and Jack have the rights to tactically lose. Thus, any of them would win the game if and only if they could win the first box containing non-trivial pockets (here defined as pockets with more than 11 nut, we'll call a box having at least one non-trivial pocket a non-trivial box) if both play optimally until there — as proven above, if they could theoretically win it, they could also tactically lose it, thus they would have full control of the game, and they could make a decision in accordance with whatever partition coming next in the remaining pockets.We'll denote ll as the number of trivial pockets (i.e. pockets with 11 nut each) standing at the left side of array aa, i.e., the (l+1)th(l+1)th pocket will be the leftmost one to have more than 11 nut. We'll consider all possible options for first boxes containing non-trivial pockets, and thus we'll iterate rr in range [l+1,n][l+1,n]: First, we denote P(r)P(r) as the xor sum of all elements of the prefix of array aa up until the rthrth element. This value will determine how much control Alice would have. If P(r)=0P(r)=0, Alice will lose in all cases with the first non-trivial box ending at rr. Proof is simple: if this box has an even amount of 11s before it, obviously Alice will be the starting player of a game with nimber of 00 and thus cannot control it to her will; and if the amount of preceding 11s is odd, then the first non-trivial box is a game with nimber of 11 and Jack as first player, thus Jack retains full control. If P(r)=1P(r)=1, Alice will win in all cases with the first non-trivial box ending at rr. Proof is literally the reverse of the above case. If P(r)>1P(r)>1, both Alice and Jack have full control to win it, thus Alice will win if and only if she is the starting player of the game at the first non-trivial box. So we have the detailed winning condition. Now, towards the maths. First, whatever pockets after the first non-trivial box doesn't matter. Thus, for each rr, there exists 2max(0,n−r−1)2max(0,n−r−1) different partitions of the pockets following the rthrth one. We don't consider cases with P(r)=0P(r)=0, obviously. If P(r)=1P(r)=1, all partitions involving only the first ll pockets are allowed. In fact, there are l+1l+1 items here: ll trivial pockets, and the first non-trivial blob always coming last, thus the number of different partitions of the pockets preceding the rthrth one in this case is 2l2l. If P(r)>1P(r)>1, we'll consider all even l0l0 in range [0,l][0,l], with l0l0 denoting the number of 11s not within the first non-trivial box. Clearly, for each l0l0, the number of different partitions would be 2max(0,l0−1)2max(0,l0−1). And since ll is fixed and this process has no relation with rr, this value could be pre-calculated. In more details, denoting that value as MM, we have M=∑⌊l02⌋i=02max(0,2i−1)M=∑i=0⌊l02⌋2max(0,2i−1). All powers of 22 could be pre-calculated as well, saving a considerable amount of runtime. All pre-calculations have time complexity in linear order of the maximum size of array aa. Time complexity: O(n)O(n).",
        "code": "class Solution:\n    hasMultipleTests = True\n\n    n: int = None\n    a: list = None\n    \n    MAXN: int = 1000000\n    MOD: int = 998244353\n    pow2: list = None\n\n    @classmethod\n    def preprocess(cls):\n        cls.pow2 = [None for _ in range(cls.MAXN)]\n        for i in range(cls.MAXN):\n            cls.pow2[i] = 1 if i == 0 else (2 * cls.pow2[i-1]) % cls.MOD\n\n    @classmethod\n    def input(cls, testcase):\n        cls.n = int(input())\n        cls.a = list(map(int, input().split()))\n\n    @classmethod\n    def solve(cls, testcase):\n        if max(cls.a) == 1:\n            return(print(cls.pow2[cls.n-1] if cls.n & 1 else 0))\n        \n        ans = 0\n\n        # The critical layer (assuming prefix Grundy > 1) can only fall into Alice's control\n        # if and only if before it is an even amount of pockets\n        alice_at_critical = 1\n        prefix_1 = 0\n        while cls.a[prefix_1] == 1:\n            prefix_1 += 1\n            \n            if prefix_1 % 2 == 0:\n                alice_at_critical = (alice_at_critical + cls.pow2[prefix_1 - 1]) % cls.MOD\n                \n        grundy = prefix_1 & 1\n        for r in range(prefix_1, cls.n):\n            grundy ^= cls.a[r]\n            \n            if grundy == 0: continue\n        \n            post_critical = cls.pow2[cls.n - 2 - r] if r < cls.n - 1 else 1\n            pre_critical = cls.pow2[prefix_1] if grundy == 1 else alice_at_critical\n            \n            ans = (ans + pre_critical * post_critical) % cls.MOD\n            \n        print(ans)\n\n# end Solution"
    }
}